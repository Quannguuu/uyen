<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tặng Lê Uyên</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050505;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #eee;
        }
        h1 { margin: 25px 0; font-weight: 200; letter-spacing: 4px; text-transform: uppercase; opacity: 0.8; }
        .controls { margin-bottom: 25px; display: flex; gap: 15px; }
        button {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #eee; padding: 10px 24px; border-radius: 30px;
            cursor: pointer; transition: all 0.3s ease;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-1px); }
        .canvas-container { border-radius: 20px; overflow: hidden; box-shadow: 0 10px 40px rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.05); }
        #canvas { background: #000; cursor: crosshair; display: block; }
    </style>
</head>
<body>

    <h1>Hoa nhà "trồng"</h1>

    <div class="controls">
        <button id="clean-btn">Xóa tất cả</button>
        <button id="auto-grow-btn">Mọc tự động</button>
        <button id="save-btn">Lưu ảnh</button>
    </div>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const cleanBtn = document.getElementById('clean-btn');
        const autoGrowBtn = document.getElementById('auto-grow-btn');
        const saveBtn = document.getElementById('save-btn');

        canvas.width = 800;
        canvas.height = 600;

        const palettes = [
            { main: 'rgba(255, 20, 100, 0.8)', light: 'rgba(255, 180, 210, 0.9)' },  // Hồng đậm
            { main: 'rgba(0, 220, 255, 0.8)', light: 'rgba(180, 250, 255, 0.9)' },  // Xanh dương neon
            { main: 'rgba(160, 50, 255, 0.8)', light: 'rgba(220, 180, 255, 0.9)' }, // Tím điện tử
            { main: 'rgba(255, 200, 0, 0.8)', light: 'rgba(255, 255, 150, 0.9)' },  // Vàng nắng
            { main: 'rgba(255, 100, 0, 0.8)', light: 'rgba(255, 200, 100, 0.9)' },  // Cam hoàng hôn
            { main: 'rgba(0, 255, 150, 0.8)', light: 'rgba(150, 255, 220, 0.9)' },  // Xanh ngọc
            { main: 'rgba(255, 255, 255, 0.7)', light: 'rgba(200, 230, 255, 0.9)' } // Trắng kim cương
        ];

        function random(min, max) { return Math.random() * (max - min) + min; }

        function drawFlowerHead(x, y, angle, scale) {
            const colorSet = palettes[Math.floor(Math.random() * palettes.length)];
            
            const numPetals = 4; 
            const petalLength = 55 * scale;
            const petalWidth = 18 * scale;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 2); 

    
            ctx.fillStyle = '#1e3d2f';
            ctx.beginPath();
            ctx.arc(0, 0, 2.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 0.85;
        
            const totalSpread = Math.PI * 0.4; 
            const angleStep = totalSpread / (numPetals - 1);

            for (let i = 0; i < numPetals; i++) {
                const petalAngle = (i * angleStep) - (totalSpread / 2);

                ctx.save();
                ctx.rotate(petalAngle);
                
                const grad = ctx.createLinearGradient(0, 0, 0, -petalLength);
                grad.addColorStop(0, colorSet.main);
                grad.addColorStop(1, colorSet.light);

                ctx.fillStyle = grad;
                ctx.shadowBlur = 10;
                ctx.shadowColor = colorSet.main;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(-petalWidth, -petalLength * 0.4, -petalWidth * 0.5, -petalLength, 0, -petalLength);
                ctx.bezierCurveTo(petalWidth * 0.5, -petalLength, petalWidth, -petalLength * 0.4, 0, 0);
                ctx.fill();
                
                ctx.restore();
            }
            ctx.restore();
        }

        function growFlower(targetX, targetY) {
            const startX = targetX + random(-15, 15);
            const startY = canvas.height + 10;
            let progress = 0;
            const speed = 0.018;
            
            const cp1x = startX + random(-40, 40);
            const cp1y = startY - (startY - targetY) * 0.35;
            const cp2x = targetX + random(-40, 40);
            const cp2y = startY - (startY - targetY) * 0.65;

            function animate() {
                if (progress <= 1) {
                    const t = progress;
                    const xt = Math.pow(1-t, 3)*startX + 3*Math.pow(1-t, 2)*t*cp1x + 3*(1-t)*Math.pow(t, 2)*cp2x + Math.pow(t, 3)*targetX;
                    const yt = Math.pow(1-t, 3)*startY + 3*Math.pow(1-t, 2)*t*cp1y + 3*(1-t)*Math.pow(t, 2)*cp2y + Math.pow(t, 3)*targetY;

                    const tPrev = Math.max(0, t - 0.02);
                    const xPrev = Math.pow(1-tPrev, 3)*startX + 3*Math.pow(1-tPrev, 2)*tPrev*cp1x + 3*(1-tPrev)*Math.pow(tPrev, 2)*cp2x + Math.pow(tPrev, 3)*targetX;
                    const yPrev = Math.pow(1-tPrev, 3)*startY + 3*Math.pow(1-tPrev, 2)*tPrev*cp1y + 3*(1-tPrev)*Math.pow(tPrev, 2)*cp2y + Math.pow(tPrev, 3)*targetY;

                    ctx.beginPath();
                    ctx.strokeStyle = '#2d5a45';
                    ctx.lineWidth = 3.2 - (3.2 - 1.2) * t; 
                    ctx.lineCap = 'round';
                    ctx.moveTo(xPrev, yPrev);
                    ctx.lineTo(xt, yt);
                    ctx.stroke();

                    progress += speed;
                    requestAnimationFrame(animate);
                } else {
                    const tx = 3 * Math.pow(1-1, 2)*(cp1x-startX) + 6*(1-1)*1*(cp2x-cp1x) + 3*Math.pow(1, 2)*(targetX-cp2x);
                    const ty = 3 * Math.pow(1-1, 2)*(cp1y-startY) + 6*(1-1)*1*(cp2y-cp1y) + 3*Math.pow(1, 2)*(targetY-cp2y);
                    const finalAngle = Math.atan2(ty, tx);
                    drawFlowerHead(targetX, targetY, finalAngle, random(0.8, 1.1));
                }
            }
            animate();
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            growFlower(e.clientX - rect.left, e.clientY - rect.top);
        });

        cleanBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        let isAuto = false;
        let autoInterval;
        autoGrowBtn.addEventListener('click', () => {
            isAuto = !isAuto;
            autoGrowBtn.innerText = isAuto ? "Tạm dừng" : "Mọc tự động";
            if(isAuto) {
                autoInterval = setInterval(() => {
                    growFlower(random(50, canvas.width-50), random(100, canvas.height-200));
                }, 1200);
            } else {
                clearInterval(autoInterval);
            }
        });

        saveBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'tang-le-uyen.png';
            link.href = canvas.toDataURL();
            link.click();
        });
    </script>
</body>
<<<<<<< HEAD
</html>
=======
</html>
>>>>>>> ab2063365ed4d4ae7bf451e93c76d51e202683f2
